From e748e9895a8e7109439855ffe40f0c92b89f9549 Mon Sep 17 00:00:00 2001
From: Portisch <hugo.portisch@yahoo.de>
Date: Thu, 18 Apr 2019 06:02:18 +0000
Subject: [PATCH] AMLCodec: speedup and optimized DequeueBuffer RenderManager:
 added queue size in late frame calculation

---
 .../VideoPlayer/DVDCodecs/Video/AMLCodec.cpp  | 36 ++++++++++---------
 .../VideoRenderers/RenderManager.cpp          |  5 ++-
 2 files changed, 23 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
index 5bfe1e1b2e5..9ade123a0fd 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
@@ -2068,31 +2068,37 @@ int CAMLCodec::DequeueBuffer()
   //Driver change from 10 to 0ms latency, throttle here
   std::chrono::time_point<std::chrono::system_clock> now(std::chrono::system_clock::now());
 
-  unsigned int waitTime(500);
+  unsigned int waitTime(5);
+  bool timeout(false);
 DRAIN:
   if (m_amlVideoFile->IOControl(VIDIOC_DQBUF, &vbuf) < 0)
   {
     if (errno != EAGAIN)
       CLog::Log(LOGERROR, "CAMLCodec::DequeueBuffer - VIDIOC_DQBUF failed: %s", strerror(errno));
 
-    std::chrono::microseconds elapsed(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - now).count());
+    std::chrono::milliseconds elapsed(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count());
 
-    if (elapsed < std::chrono::microseconds(waitTime))
-      std::this_thread::sleep_for(std::chrono::microseconds(waitTime) - elapsed);
+    if (elapsed < std::chrono::milliseconds(waitTime))
+      std::this_thread::sleep_for(std::chrono::milliseconds(waitTime) - elapsed);
 
-    if (m_drain && elapsed < std::chrono::milliseconds(300))
+    timeout = elapsed >= std::chrono::milliseconds(300);
+
+    if (m_drain && !timeout)
       goto DRAIN;
 
-    if (!m_drain && elapsed < std::chrono::milliseconds(300))
-      CLog::Log(LOGDEBUG, LOGAVTIMING, "CAMLCodec::DequeueBuffer skipped by %s", strerror(errno));
-    else if (m_drain && elapsed > std::chrono::milliseconds(300))
+    if (m_drain && timeout)
       CLog::Log(LOGDEBUG, LOGAVTIMING, "CAMLCodec::DequeueBuffer timeout!");
 
     return -errno;
   }
 
-  int waited = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - now).count();
-  CLog::Log(LOGDEBUG, LOGAVTIMING, "CAMLCodec::DequeueBuffer waited:%0.3fms", waited / 1000.0);
+  if (m_drain)
+  {
+    int waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count();
+    CLog::Log(LOGDEBUG, LOGAVTIMING, "CAMLCodec::DequeueBuffer waited:%0.3fms", waited / 1000.0);
+  }
+  else
+    CLog::Log(LOGDEBUG, LOGAVTIMING, "CAMLCodec::DequeueBuffer vidioc_dqbuf successful");
 
   // Since kernel 3.14 Amlogic changed length and units of PTS values reported here.
   // To differentiate such PTS values we check for existence of omx_pts_interval_lower
@@ -2153,7 +2159,7 @@ CDVDVideoCodec::VCReturn CAMLCodec::GetPicture(VideoPicture *pVideoPicture)
       pVideoPicture->iDuration = static_cast<double>((0x7FFFFFFF & (m_cur_pts - m_last_pts)) * DVD_TIME_BASE) / PTS_FREQ;
 
     pVideoPicture->dts = DVD_NOPTS_VALUE;
-    pVideoPicture->pts = static_cast<double>(m_cur_pts + m_ptsOverflow) / PTS_FREQ * DVD_TIME_BASE;
+    pVideoPicture->pts = static_cast<double>(m_cur_pts + m_ptsOverflow) * DVD_TIME_BASE / PTS_FREQ;
 
     CLog::Log(LOGDEBUG, LOGVIDEO, "CAMLCodec::GetPicture: index: %u, pts: %0.4lf[%llX], overflow: %llX",m_bufferIndex, pVideoPicture->pts/DVD_TIME_BASE, m_cur_pts, m_ptsOverflow);
 
@@ -2161,12 +2167,8 @@ CDVDVideoCodec::VCReturn CAMLCodec::GetPicture(VideoPicture *pVideoPicture)
   }
   else if (m_drain)
     return CDVDVideoCodec::VC_EOF;
-  else
-  {
-    if (timesize < 1.0)
-      return CDVDVideoCodec::VC_BUFFER;
-    usleep(5000);
-  }
+  else if (timesize < 1.0)
+    return CDVDVideoCodec::VC_BUFFER;
 
   return CDVDVideoCodec::VC_NONE;
 }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index d3ed35eaa2e..dfa0d988045 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -1149,6 +1149,8 @@ void CRenderManager::PrepareNextRender()
     auto iter = m_queued.begin();
     int idx = *iter;
     int lateframes = 0;
+    int queue_size = m_queued.size();
+
     while (iter != m_queued.end())
     {
       // the slot for rendering in time is [pts .. (pts +  x * frametime)]
@@ -1156,9 +1158,10 @@ void CRenderManager::PrepareNextRender()
       // we are really late. The likelihood that we recover decreases the greater m_lateframes
       // get. Skipping a frame is easier than having decoder dropping one (lateframes > 10)
       double x = (m_lateframes <= 6) ? 0.98 : 0;
-      if (renderPts < m_Queue[*iter].pts + x * frametime)
+      if ((renderPts - frametime * queue_size) < (m_Queue[*iter].pts + x * frametime))
         break;
       lateframes++;
+      queue_size--;
       idx = *iter;
       ++iter;
     }
