From 6b3506384a48738a33108a9e02c16e9c81b59312 Mon Sep 17 00:00:00 2001
From: Arthur Liberman <arthur_liberman@hotmail.com>
Date: Fri, 1 Mar 2019 22:11:53 +0200
Subject: [PATCH] aml: Multichannel-PCM and HD Audio passthrough

1. If we want passthrough, is should be redirected to device 1. To make sure device 1 output is enabled, set device 0 to stereo.
2. Set digital_codec parameter to notify sound driver about audio format.
3. Amlogic wants 48kHz for EAC3 passthrough.
4. Identify Amlogic audio output as HDMI.
---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 82 ++++++++++++++++++++-
 1 file changed, 79 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 27447e4b48b..4ff43b4b7c1 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -20,6 +20,7 @@
 
 #if defined(HAS_LIBAMCODEC)
 #include "utils/AMLUtils.h"
+#include "utils/SysfsUtils.h"
 #endif
 
 #include <algorithm>
@@ -52,6 +53,39 @@ static enum AEChannel ALSAChannelMapPassthrough[ALSA_MAX_CHANNELS + 1] = {
   AE_CH_NULL
 };
 
+enum AMLDeviceType
+{
+  AML_NONE, AML_M8AUDIO, AML_MESONAUDIO, AML_AUGESOUND
+};
+
+AMLDeviceType GetAMLDeviceType(const std::string &device)
+{
+  AMLDeviceType amlDeviceType = AML_NONE;
+  if (device.find("AUGESOUND") != std::string::npos)
+    amlDeviceType = AML_AUGESOUND;
+  else if (device.find("MESONAUDIO") != std::string::npos)
+    amlDeviceType = AML_MESONAUDIO;
+  else if (device.find("M8AUDIO") != std::string::npos)
+    amlDeviceType = AML_M8AUDIO;
+  return amlDeviceType;
+}
+
+std::string GetAMLCardName(AMLDeviceType type)
+{
+  switch (type)
+  {
+    case AML_AUGESOUND:
+      return "AUGESOUND";
+    case AML_MESONAUDIO:
+      return "MESONAUDIO";
+    case AML_M8AUDIO:
+      return "M8AUDIO";
+    case AML_NONE:
+    default:
+      return "";
+  }
+}
+
 static unsigned int ALSASampleRateList[] =
 {
   5512,
@@ -500,12 +534,49 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   {
     m_passthrough   = false;
   }
-#if defined(HAS_LIBAMCODEC)
-  if (aml_present())
+
+  AMLDeviceType amlDeviceType = GetAMLDeviceType(device);
+  if (amlDeviceType != AML_NONE)
   {
+    int aml_digital_codec = 0;
+
+    if (m_passthrough)
+    {
+      switch(format.m_streamInfo.m_type)
+      {
+        case CAEStreamInfo::STREAM_TYPE_AC3:
+          aml_digital_codec = 2;
+          break;
+
+        case CAEStreamInfo::STREAM_TYPE_DTS_512:
+        case CAEStreamInfo::STREAM_TYPE_DTS_1024:
+        case CAEStreamInfo::STREAM_TYPE_DTS_2048:
+        case CAEStreamInfo::STREAM_TYPE_DTSHD_CORE:
+        case CAEStreamInfo::STREAM_TYPE_DTSHD:
+          aml_digital_codec = 3;
+          break;
+
+        case CAEStreamInfo::STREAM_TYPE_EAC3:
+          aml_digital_codec = 4;
+          break;
+
+        case CAEStreamInfo::STREAM_TYPE_DTSHD_MA:
+          aml_digital_codec = 8;
+          break;
+
+        case CAEStreamInfo::STREAM_TYPE_TRUEHD:
+          aml_digital_codec = 7;
+          break;
+      }
+    }
+    else
+    {
+      device = "@:CARD=AML" + GetAMLCardName(amlDeviceType) + ",DEV=0";
+    }
+
     aml_set_audio_passthrough(m_passthrough);
+    SysfsUtils::SetInt("/sys/class/audiodsp/digital_codec", aml_digital_codec);
   }
-#endif
 
   if (inconfig.channels == 0)
   {
@@ -1552,6 +1623,11 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
       info.m_dataFormats.push_back(i);
   }
 
+  if (GetAMLDeviceType(info.m_displayName) != AML_NONE && info.m_deviceType != AE_DEVTYPE_HDMI)
+  {
+    info.m_displayNameExtra = "PCM";
+  }
+
   if (info.m_deviceType == AE_DEVTYPE_HDMI)
   {
     // we don't trust ELD information and push back our supported formats explicitly
